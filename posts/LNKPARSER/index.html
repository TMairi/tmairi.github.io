<!DOCTYPE html><html lang="en-UK" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content=""><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Forensic BASH Scripting: LNK Parsing" /><meta name="author" content="Mairi" /><meta property="og:locale" content="en_UK" /><meta name="description" content="Forensic BASH script: lnkparser" /><meta property="og:description" content="Forensic BASH script: lnkparser" /><link rel="canonical" href="https://tmairi.github.io/posts/LNKPARSER/" /><meta property="og:url" content="https://tmairi.github.io/posts/LNKPARSER/" /><meta property="og:site_name" content="Mairi’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-08T20:56:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Forensic BASH Scripting: LNK Parsing" /><meta name="twitter:site" content="@AstrumMairi" /><meta name="twitter:creator" content="@Mairi" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mairi"},"dateModified":"2021-05-10T19:09:51+01:00","datePublished":"2021-04-08T20:56:00+01:00","description":"Forensic BASH script: lnkparser","headline":"Forensic BASH Scripting: LNK Parsing","mainEntityOfPage":{"@type":"WebPage","@id":"https://tmairi.github.io/posts/LNKPARSER/"},"url":"https://tmairi.github.io/posts/LNKPARSER/"}</script><title>Forensic BASH Scripting: LNK Parsing | Mairi's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="mask-icon" href="/assets/img/favicons/safari-pinned-tab.svg" color="#5bbad5"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/LOGO.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Mairi's Blog</a></div><div class="site-subtitle font-italic">Science, Research & Development</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/TMairi" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/AstrumMairi" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Forensic BASH Scripting: LNK Parsing</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Forensic BASH Scripting: LNK Parsing</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Mairi </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 8, 2021, 8:56 PM +0100" prep="on" > Apr 8 <i class="unloaded">2021-04-08T20:56:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, May 10, 2021, 6:09 PM +0000" prefix="Updated " > May 10 <i class="unloaded">2021-05-10T19:09:51+01:00</i> </span> </span></div></div><div class="post-content"><p>Forensic <code class="language-plaintext highlighter-rouge">BASH</code> script: <a href="https://github.com/TMairi/lnkparser/blob/master/lnkparser">lnkparser</a></p><h2 id="observation">Observation</h2><p>Recently, while probing a Windows image file in my spare time, I came across a plethora of user-generated Windows shortcut files, also known as LNK files as denoted by their extension <code class="language-plaintext highlighter-rouge">.lnk</code>. A quick look into the hexadecimal output of one of these LNK files showed that there was a lot of valuable information which could be extracted. Therefore, I went searching for a parsing tool which could pull this data for me.</p><p>However, being a Linux user, I found that most of the parsers available online, such as Eric Zimmerman’s <a href="https://ericzimmerman.github.io/#!index.md">LECmd</a> program, were PE (Portable Executable) files for use on Windows machines. Therefore, I began my research into how feasible it would be to create a script, written completely in <code class="language-plaintext highlighter-rouge">BASH</code> (shell), to parse out the contents of the LNK files.</p><p>One of the primary design goals of this hypothetical shell script was to rely solely on typical Linux tools which come as standard on any mainstream distribution, such as; <code class="language-plaintext highlighter-rouge">xxd</code> (for reading hexadecimal data), <code class="language-plaintext highlighter-rouge">sed</code>/<code class="language-plaintext highlighter-rouge">awk</code> (for transforming the output data for better parsing) and <code class="language-plaintext highlighter-rouge">printf</code> (for feeding the data back to the end-user). I purposefully avoided making the script dependant on external tools such as <code class="language-plaintext highlighter-rouge">bc</code>, so it would <em>hopefully</em> be able to work on most Linux distributions without issues.</p><h2 id="research">Research</h2><p>This article will not provide an in-depth look into the forensic relevance of LNK files, nor their use in an investigation, as this topic has already been covered many times by various articles; <a href="https://www.magnetforensics.com/blog/forensic-analysis-of-lnk-files/">1</a>, <a href="https://forensicswiki.xyz/wiki/index.php?title=LNK">2</a>, <a href="https://www.forensicfocus.com/articles/evidentiary-value-of-link-files/">3</a>. This article is purely to document how my LNK parsing script works and the devlopment process I went through while writing the code.</p><p>As with every task or problem I am faced with, I use the <a href="https://en.wikipedia.org/wiki/Scientific_method">scientific method</a> to help me structure a plan of action. As we can extrapolate from my earlier comments, I already have my question; <em>“Is it possible to reliably parse out useful data from LNK files using only shell script?”</em>. Hence, the next step (my favourite part), is to conduct research, which I split into three phases:</p><ol><li>Understand the LNK data structures and what data they contain<li>Understand the potential limitations of <code class="language-plaintext highlighter-rouge">BASH</code> in relation to parsing the data structures<li>Obtain multiple, valid LNK files with varying data for the experimentation and testing phase</ol><p>To better understand the data structures comprising an LNK file, I turned to the official documentation supplied by Microsoft and found that the ‘Shell Link Binary File’ (LNK) format was detailed <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/99e8d0e5-5bc6-4aed-af37-da7f584f832a">here</a>. I will not explain in-depth what these structures are, or what data they provide, as this has already been explained in the aforementioned documentation, as well as other forensic articles online, e.g.; <a href="https://u0041.co/blog/post/4">Exploring Windows Artifacts: LNK Files</a>. The official documentation also provides an <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/4d25bbad-09b7-4322-8c0a-521d268481bb">example</a> break-down of a given LNK file, which proved to be a very useful reference guide for some of the structures.</p><h3 id="link-flag-parsing">Link Flag Parsing</h3><p>Looking at the data structures, it seemed that their offset values are relatively straightforward. In the first structure, the <strong>SHELL_LINK_HEADER</strong>, I noted that the 4 byte <code class="language-plaintext highlighter-rouge">LinkFlags</code> structure (Offset <code class="language-plaintext highlighter-rouge">0x0014</code>) would be the first challenge to parse using only Linux <code class="language-plaintext highlighter-rouge">BASH</code> commands due to the various bit values which can be set. After writing some pseudo-code, I figured I could get this to work by creating two arrays; one containing the flag value as specified in the documentation, and the other containing the binary value (<code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">0</code>) of said flag. These two arrays would then be compared via a ‘for loop’ and the script would output any flag whose binary value equals <code class="language-plaintext highlighter-rouge">1</code> (i.e. that flag is ‘set’).</p><h3 id="filetime-timestamps">FILETIME Timestamps</h3><p>Interestingly, I also used a similar array comparison method to achieve the same results for the target file attribute data, also stored in the header structure. The next challenge from this structure was the timestamps, which required a conversion from <code class="language-plaintext highlighter-rouge">FILETIME</code> format to <code class="language-plaintext highlighter-rouge">Unix</code> time, to then be decoded with the following command:</p><p><code class="language-plaintext highlighter-rouge">date -d@&lt;UNIX_TIME&gt;</code></p><p>As a result of my research, converting the timestamps was relatively easy to implement in shell script:</p><ol><li>Calculate the difference between the epochs (<code class="language-plaintext highlighter-rouge">FILETIME</code>: 1601-01-01 -&gt; <code class="language-plaintext highlighter-rouge">Unix</code>: 1970-01-01) in seconds<li>Read the 8-byte hexadecimal <code class="language-plaintext highlighter-rouge">FILETIME</code> timestamp value in little-endian format<li>Convert this hexadecimal value to decimal<li>Divide the decimal value by 10000000 and then minus the epoch difference to get the <code class="language-plaintext highlighter-rouge">Unix</code> timestamp<li>Decode the <code class="language-plaintext highlighter-rouge">Unix</code> timestamp using the <code class="language-plaintext highlighter-rouge">date</code> command</ol><h3 id="shell-items">Shell Items</h3><p>The next structure I found challenging to deal with was the <strong>IDList</strong>. During the research phase, I found that this structure could potentially contain shell items, which are notably undocumented by Microsoft. However, I did come across a very helpful <a href="https://github.com/libyal/libfwsi/blob/main/documentation/Windows%20Shell%20Item%20format.asciidoc">repository</a> which outlines a data format specification for these shell items. Of these undocumented shell items, I was most interested in parsing out the Operating System version information and MFT INDEX values where available.</p><h3 id="fat-timestamps">FAT Timestamps</h3><p>However, within these Shell Items, I came across another potential issue stemming from the limitations of <code class="language-plaintext highlighter-rouge">BASH</code>; the Creation and Access timestamps in the shell items are in <code class="language-plaintext highlighter-rouge">MS-DOS</code> (FAT) format. Fortunately, this format is <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime?redirectedfrom=MSDN">documented</a> by Microsoft, wherein I discovered that the 4 byte timestamp values are simply a binary bitmask. Therefore, in <code class="language-plaintext highlighter-rouge">BASH</code>, all I had to do was parse out the 32-bit binary string for the given timestamp, separate the values according to their bitmask, convert each value to decimal and then append them together to form a readable timestamp.</p><h3 id="file-path-parsing">File Path Parsing</h3><p>Following this, the other structure I anticipated <code class="language-plaintext highlighter-rouge">BASH</code>-related problems with was <strong>LINK_INFO</strong>, specifically when dealing with the target file path (<code class="language-plaintext highlighter-rouge">LocalBasePath</code>). The reason I foresaw issues here is that the target file name could consist of many characters (especially on NTFS file systems) and there was no data within the LNK file to specify exactly how long this path was. However, there was the <code class="language-plaintext highlighter-rouge">LocalBasePathOffset</code> within the <strong>LINK_INFO</strong> structure which would tell me where in the LNK file the file path began. Therefore, I figured I could calculate the length of the <code class="language-plaintext highlighter-rouge">LocalBasePath</code> by reading the data starting from the offset value, until it hit the NULL-terminated string called the <code class="language-plaintext highlighter-rouge">CommonPathSuffix</code>. Thus the data read between the offset and the NULL string would comprise the full target file path, which could then be converted into ASCII.</p><h3 id="extracting-lnk-files">Extracting LNK Files</h3><p>With the LNK data structures and the potential issues I may encounter within <code class="language-plaintext highlighter-rouge">BASH</code> solved, I then looked to acquiring some valid LNK files I could use for testing the script as it was being developed. Luckily, I had access to Windows image files ranging from XP to 10, from which I could extract a rather modest sample size from. To bulk-extract these files from a given Windows image, I simply used the following <code class="language-plaintext highlighter-rouge">sleuthkit</code> commands:</p><ul><li><code class="language-plaintext highlighter-rouge">mmls image.raw</code><li><code class="language-plaintext highlighter-rouge">fls -o 63 -Fru image.raw &gt; all.files</code><li><code class="language-plaintext highlighter-rouge">grep "\.lnk$" all.files | grep Recent | sed -n 's|^.* \(.*\):.*|\1|p' | sed -n 's|^\(.*\)-.*-.*|\1|p' &gt; inodes</code><li><code class="language-plaintext highlighter-rouge">for inode in $(cat inodes); do icat -o 63 image.raw $inode &gt; $i.lnk; done</code></ul><p>From the above commands, I use <code class="language-plaintext highlighter-rouge">mmls</code> to determine the starting sector offset value of the primary NTFS partition to query (<code class="language-plaintext highlighter-rouge">63</code>). Then I used <code class="language-plaintext highlighter-rouge">fls</code> to list all files <code class="language-plaintext highlighter-rouge">-F</code>, recursively looking in all directories <code class="language-plaintext highlighter-rouge">-r</code>, only for allocated (undeleted) files <code class="language-plaintext highlighter-rouge">-u</code>, and output the list to a file named <code class="language-plaintext highlighter-rouge">all.files</code>. I then used a combination of <code class="language-plaintext highlighter-rouge">grep</code> and <code class="language-plaintext highlighter-rouge">sed</code> to look for potentially user-created (Recent) LNK files, only display their corresponding MFT entry (inode) value and write the list to a file (<code class="language-plaintext highlighter-rouge">inodes</code>). Then simply use a <code class="language-plaintext highlighter-rouge">for</code> loop in combination with <code class="language-plaintext highlighter-rouge">icat</code> to iterate through these inode values and extract them. Once this process was repeated for multiple image files, I had over 200 LNK files ready to be tested.</p><h2 id="hypothesis">Hypothesis</h2><p>Once I had completed my research and gathered my samples, I then posed my hypothesis; <em>It is possible to extract the contents of LNK files using only standard Linux tools</em>. With this, I began testing my hypothesis through developing the <code class="language-plaintext highlighter-rouge">BASH</code> script. The experimentation process was conducted on the sample files each time functionality was added to the main script.</p><h2 id="experimentation--testing">Experimentation / Testing</h2><p>For example, the first parser I wrote was a simple check to ensure that the LNK file header was correct; <code class="language-plaintext highlighter-rouge">0x0000004C</code>, in addition to the CLSID value; <code class="language-plaintext highlighter-rouge">00021401-0000-0000-C000-000000000046</code>. I used this as a control variable of sorts to ensure that my basic <code class="language-plaintext highlighter-rouge">xxd</code> parsers would work on the sample files. Using a <code class="language-plaintext highlighter-rouge">for</code> loop to run the header check against all of my LNK files, in addition to some known ‘negative’ (non-LNK) files proved that it worked.</p><p>In some cases, I would encounter errors when analysing the results of the experiment, whereby a parser may work for one LNK file as intended, but not another. Often this was simply attributed to a coding oversight or incorrect handling of the data structure, which could be remediated without issue.</p><p>I also encountered a problem when adding output functionality to the script, as I wanted the user to be able to write the contents of <code class="language-plaintext highlighter-rouge">STDOUT</code> to a CSV file for compatibility reasons. I wound up having to write the contents of the parser to a temporary file each time it was executed and remove this file each time unless the user explicitly uses the output <code class="language-plaintext highlighter-rouge">-o</code> argument. This is not an ideal solution by any means, but it works given the design limitations of the script.</p><h2 id="data-analysis">Data Analysis</h2><p>Once the primary functionality of the script was written and fully tested, I could review the results. Most importantly; the script works well and does not rely on external tools or libraries to parse out the LNK data structures. Every LNK sample file I had was tested and barring a few sparse files, each one produced data which could prove very useful for a forensic examiner. However, there were a few issues during the analysis phase I noticed:</p><ul><li>The script does not handle unicode characters well</ul><p>Only a small handful of the files tested appeared to contain unicode characters in the file paths, which caused an issue with the parsers combining data sets. This is not a major issue as the data is still readable, just not in a very nice format. This would need more testing with LNK files before I can definitively fix the issue.</p><ul><li>The script does not parse out Network Share data</ul><p>Unfortunately, none of the samples I had to hand contained Network Share data under the <code class="language-plaintext highlighter-rouge">CommonNetworkRelativeLink</code> structure. Therefore, no parsers for this data have been written as I would not have been able to test them properly. Again, this requires more sample files, preferably with valid structures containing data in this particular structure to remedy.</p><h2 id="conclusion">Conclusion</h2><p>In conclusion, the script was deemed complete and working as intended and was then released onto my GitHub page, which you can find <a href="https://github.com/TMairi/lnkparser">here</a>. If you have any recommendations or questions about this script, or the development process outline above, you can contact me on <a href="https://twitter.com/AstrumMairi">Twitter</a>.</p><p>– Mairi</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dfir/'>DFIR</a>, <a href='/categories/linux/'>Linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/dfir/" class="post-tag no-text-decoration" >dfir</a> <a href="/tags/bash/" class="post-tag no-text-decoration" >bash</a> <a href="/tags/linux/" class="post-tag no-text-decoration" >linux</a> <a href="/tags/scripting/" class="post-tag no-text-decoration" >scripting</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Forensic BASH Scripting: LNK Parsing - Mairi's Blog&url=https://tmairi.github.io/posts/LNKPARSER/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Forensic BASH Scripting: LNK Parsing - Mairi's Blog&u=https://tmairi.github.io/posts/LNKPARSER/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Forensic BASH Scripting: LNK Parsing - Mairi's Blog&url=https://tmairi.github.io/posts/LNKPARSER/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/dissecting-the-ad1-file-format/">Dissecting the AD1 File Format</a><li><a href="/posts/exploring-ieee-754-arithmetic/">Exploring IEEE 754 Arithmetic</a><li><a href="/posts/LNKPARSER/">Forensic BASH Scripting: LNK Parsing</a><li><a href="/posts/forensic-aquisition-with-dd-tools/">Forensic Acquisition with DD Tools</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/dfir/">dfir</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/scripting/">scripting</a> <a class="post-tag" href="/tags/mathematics/">mathematics</a> <a class="post-tag" href="/tags/windows/">windows</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/exploring-ieee-754-arithmetic/"><div class="card-body"> <span class="timeago small" > May 10 <i class="unloaded">2021-05-10T19:33:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Exploring IEEE 754 Arithmetic</h3><div class="text-muted small"><p> Foreword This article will be covering the interesting arithmetic involved in the conversion of a hexadecimal value into an IEEE 754 (Floating-Point) value, in the context of computing. Additional...</p></div></div></a></div><div class="card"> <a href="/posts/forensic-aquisition-with-dd-tools/"><div class="card-body"> <span class="timeago small" > Jan 28 <i class="unloaded">2018-01-28T00:00:00+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Forensic Acquisition with DD Tools</h3><div class="text-muted small"><p> Foreword This article will be focusing on the usage of the Linux tool dd in the forensic imaging process, along with several tools that have been derived from it. In addition to briefly covering t...</p></div></div></a></div><div class="card"> <a href="/posts/extracting-alternate-data-streams-with-linux/"><div class="card-body"> <span class="timeago small" > Jun 22 <i class="unloaded">2018-06-22T01:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Extracting Alternate Data Streams with Linux</h3><div class="text-muted small"><p> Foreword This article will be covering a feature of the NTFS file system known as the Alternate Data Stream (ADS), focusing on how to properly identify and extract these data streams from an NTFS ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/extracting-alternate-data-streams-with-linux/" class="btn btn-outline-primary" prompt="Older"><p>Extracting Alternate Data Streams with Linux</p></a> <a href="/posts/exploring-ieee-754-arithmetic/" class="btn btn-outline-primary" prompt="Newer"><p>Exploring IEEE 754 Arithmetic</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/AstrumMairi">Mairi</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/dfir/">dfir</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/scripting/">scripting</a> <a class="post-tag" href="/tags/mathematics/">mathematics</a> <a class="post-tag" href="/tags/windows/">windows</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://tmairi.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
