<!DOCTYPE html><html lang="en-UK" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content=""><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Forensic Acquisition with DD Tools" /><meta name="author" content="Mairi" /><meta property="og:locale" content="en_UK" /><meta name="description" content="Foreword" /><meta property="og:description" content="Foreword" /><link rel="canonical" href="https://tmairi.github.io/posts/forensic-aquisition-with-dd-tools/" /><meta property="og:url" content="https://tmairi.github.io/posts/forensic-aquisition-with-dd-tools/" /><meta property="og:site_name" content="Mairi’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-01-28T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Forensic Acquisition with DD Tools" /><meta name="twitter:site" content="@AstrumMairi" /><meta name="twitter:creator" content="@Mairi" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mairi"},"dateModified":"2021-04-10T19:08:56+01:00","datePublished":"2018-01-28T00:00:00+00:00","description":"Foreword","headline":"Forensic Acquisition with DD Tools","mainEntityOfPage":{"@type":"WebPage","@id":"https://tmairi.github.io/posts/forensic-aquisition-with-dd-tools/"},"url":"https://tmairi.github.io/posts/forensic-aquisition-with-dd-tools/"}</script><title>Forensic Acquisition with DD Tools | Mairi's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="mask-icon" href="/assets/img/favicons/safari-pinned-tab.svg" color="#5bbad5"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/LOGO.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Mairi's Blog</a></div><div class="site-subtitle font-italic">Science, Research & Development</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/TMairi" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/AstrumMairi" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Forensic Acquisition with DD Tools</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Forensic Acquisition with DD Tools</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Mairi </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Jan 28, 2018, 12:00 AM +0000" prep="on" > Jan 28 <i class="unloaded">2018-01-28T00:00:00+00:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Apr 10, 2021, 6:08 PM +0000" prefix="Updated " > Apr 10 <i class="unloaded">2021-04-10T19:08:56+01:00</i> </span> </span></div></div><div class="post-content"><h2 id="foreword">Foreword</h2><p>This article will be focusing on the usage of the Linux tool <code class="language-plaintext highlighter-rouge">dd</code> in the forensic imaging process, along with several tools that have been derived from it. In addition to briefly covering the issue of data completeness when preparing to conduct forensic acquisition.</p><blockquote><p><strong>DISCLAIMER</strong>: This article was written by myself and was previously posted on a now-defunct website on 2018-01-28. I backed up the original contents of the article prior to the website shut-down and am now reposting it here for preservation. All information was correct and accurate at the time this article was written.</p></blockquote><h2 id="introduction">Introduction</h2><p>Data Duplication/Dump/Definition <code class="language-plaintext highlighter-rouge">dd</code> is a command-line tool primarily used in Unix Operating Systems. It serves a very simple, yet useful purpose; to copy data from a specified source to a specified destination. Typically, this will be done bit-by-bit, regardless of any file systems or operating systems that may be present.</p><p>The <code class="language-plaintext highlighter-rouge">dd</code> command is typically installed by default in most GNU/Linux distributions under a package called <code class="language-plaintext highlighter-rouge">coreutils</code>. However, its derivatives, which will be shown later in this post may need to be installed manually. If necessary, I will include more details about the manual installation of these tools as they are mentioned.</p><p>Owing to the many implementations of the Linux operating system, it is not uncommon to find <code class="language-plaintext highlighter-rouge">dd</code> installed on devices running Android<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. In addition, the <code class="language-plaintext highlighter-rouge">dd</code> tools can be implemented over a network using utilities like <code class="language-plaintext highlighter-rouge">cryptcat</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. However, this article will be focusing on traditional storage device imaging using the <code class="language-plaintext highlighter-rouge">dd</code> tool(s) in a non-live, local environment.</p><h3 id="linux-block-devices">Linux Block Devices</h3><p>Because everything in Linux is technically interpreted as a file, this means <code class="language-plaintext highlighter-rouge">dd</code> can interact with a plethora of data. One of the most important pieces of data being “special” files in Linux; such as block devices like <code class="language-plaintext highlighter-rouge">/dev/sda</code>.</p><p>These block devices are of the most interest to us, as they can represent physical drives attached to your host system; ranging from hard drives to optical drives and even NVME devices. Drives attached to a Linux host system will be assigned a special device in the <code class="language-plaintext highlighter-rouge">/dev</code> directory by the kernel. The naming convention for these device files includes, but is not limited to:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">BLOCK DEVICE<th style="text-align: center">TYPE<tbody><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">/dev/sdX</code><td style="text-align: center">SATA / SCSI / Serial drives<tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">/dev/hdX</code><td style="text-align: center">IDE drives<tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">/dev/fdX</code><td style="text-align: center">Floppy drives<tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">/dev/mdX</code><td style="text-align: center">RAID arrays</table></div><p>Where ‘<em>X</em>’ is a letter of the alphabet starting from ‘a’, (or a number starting from 0, for floppy drives) denoting the order of the devices. For example; your primary SATA hard drive which boots into Linux will be <code class="language-plaintext highlighter-rouge">/dev/sda</code>, while a secondary SATA hard drive will be <code class="language-plaintext highlighter-rouge">/dev/sdb</code>.</p><p>In addition, these block devices will often have similar files denoting partitions for each drive, which is usually done by appending a number to the block device. For example, the first partition of your primary SATA hard drive will be <code class="language-plaintext highlighter-rouge">/dev/sda1</code> (typically the ‘boot’ partition). However, for the purposes of this article, I am only going to be focusing on the raw device files for the drives themselves and not those of the partitions.</p><h3 id="in-a-forensic-environment">In a Forensic Environment</h3><p>In the context of digital forensic investigation; the <code class="language-plaintext highlighter-rouge">dd</code> tool and its derivatives can be used to read data from the device file of an attached drive and write this data to a raw image file. Bear in mind that the data you acquire from a device such as a hard drive, may not necessarily be complete (see ‘<strong>Data Completeness</strong>’ section below). The resulting raw image file can then be easily imported into an appropriate analysis suite, or interrogated with other command-line tools.</p><p>I personally prefer to use Linux for performing digital forensics whenever I can, and I find <code class="language-plaintext highlighter-rouge">dd</code>, along with its variants, to be invaluable tools. I would highly recommend using low-level command-line tools like <code class="language-plaintext highlighter-rouge">dd</code> to better understand the forensic process before utilizing the well-known commercial tools.</p><h2 id="data-completeness">Data Completeness</h2><p>Understanding the issue of data completeness is fundamental in the forensic acquisition process, especially when dealing with Hard Drive Disks (HDDs). There are caveats to consider when using imaging tools such as <code class="language-plaintext highlighter-rouge">dd</code>, one of them being that they may not have access to <strong>ALL</strong> of the data stored on a device. In most cases, this relates to ‘hidden areas’ commonly found on hard drives, which are typically inaccessible to the Operating System or the BIOS.</p><p>The two most common ‘hidden areas’ of a hard drive are known as the Host Protected Area (HPA) and the Device Configuration Overlay (DCO). The HPA was implemented to allow manufacturers to store diagnostic, monitoring and recovery tools on-disk. The DCO was introduced in ATA-6 and is used by manufacturers to change features between drive models and/or alter the observable capacity of the disk. These two hidden areas are simply sectors on the drive which have been specified as ‘protected’ by the drives configuration<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>.</p><p>The third and perhaps most important ‘area’ to be aware of is referred to as the Service Area, or System Area. This area can occupy a significant part of the drives total capacity and is used to store information such as:</p><ul><li>SMART data<li>Defective sector lists (P/G lists)<li>Firmware code<li>ATA passwords<li>Servo information</ul><p>Accessing the data contained in the Service Area is normally only possible via vendor-owned proprietary commands. However, Todd Shipley demonstrated via a proof-of-concept that it is possible to write data to this area, which has interesting implications for anti-forensics<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>.</p><p>It is vital to not only be aware of, but try and account for these hidden areas when conducting an investigation. Some commercial forensic software will take measures to deal with these areas, however, more so the HPA/DCO, than the Service Area. It is not uncommon for such software, or even certain write blockers, to check for the existence of HPA/DCO areas before an image is acquired<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>. On Linux, it is possible to ‘remove’ these areas by using tools such as <code class="language-plaintext highlighter-rouge">hdparm</code>, but this is outside the scope of this article.</p><p>Finally, while I am on the topic of data completeness, the USB flash drive I will be using to show off the functionality of the <code class="language-plaintext highlighter-rouge">dd</code> tools (see ‘<strong>Testing Preparation</strong>’ section below) has similar issues. All USB devices contain a hierarchy of data known as ‘descriptors’ which are used to provide information to the host system, mainly to determine the appropriate driver(s). This information includes, but is not limited to;</p><ul><li>Vendor and Manufacturer data<li>USB device type<li>Supported USB versions<li>Configuration details<li>Serial number of the device<li>Number of endpoints</ul><p>The primary descriptor found on USB drives is known as the ‘device descriptor’, which encompasses the entire device and is at the top of the hierarchy<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>. Although the device descriptor contains forensically relevant information about the USB drive, this data is stored in the Read-Only Memory (ROM) chip and will <strong>NOT</strong> be imaged when using tools like <code class="language-plaintext highlighter-rouge">dd</code>.</p><h2 id="testing-preparation">Testing Preparation</h2><p>I am going to be using the <code class="language-plaintext highlighter-rouge">dd</code> tools on a Linux system to acquire an image of an unmounted 1GB USB flash drive, without any additional hardware. In a forensic environment, the drive being imaged would ideally be connected to an appropriate hardware write blocker to preserve data integrity, along with any other procedures being taken to ensure data completeness.</p><p>You may wonder why the USB device I will be connecting to the Linux host system is assigned a block device with the naming convention <code class="language-plaintext highlighter-rouge">/dev/sdX</code>, considering the device is not connected through a SATA/SCSI interface. This is because, as of kernel version 3.15, Linux utilises a protocol called USB Attached SCSI (UAS) to facilitate the reading/writing of data to USB mass storage devices<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>.</p><p>With UAS; the SCSI command set is used for communicating with the USB device and is why, in this case, the block device uses the SCSI naming convention. You can see this process in the <code class="language-plaintext highlighter-rouge">dmesg</code> output when the USB device is connected to the host system.</p><blockquote><p><strong>WARNING</strong>: It is very important to note before I continue that <code class="language-plaintext highlighter-rouge">dd</code> is very unforgiving, especially if you enter the incorrect source and destination values. Therefore, if you are unfamiliar with <code class="language-plaintext highlighter-rouge">dd</code> I would highly recommend you run it in a controlled environment first, lest you risk corrupting or destroying your data. Always ensure you know how the tools and commands work before you run them in a live environment!</p></blockquote><h2 id="tool-1-dd">Tool #1: DD</h2><p>As mentioned previously, the standard <code class="language-plaintext highlighter-rouge">dd</code> tool is installed by default on most GNU/Linux distributions under the <code class="language-plaintext highlighter-rouge">coreutils</code> package<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>. Using <code class="language-plaintext highlighter-rouge">dd</code> on the Linux command-line is very simple and given the block device we want to image is <code class="language-plaintext highlighter-rouge">/dev/sdb</code>, a typical <code class="language-plaintext highlighter-rouge">dd</code> command might look like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>dd if=/dev/sdb of=USB_image.dd bs=4k conv=noerror,sync status=progress
</pre></table></code></div></div><h3 id="dd-parameters">DD Parameters</h3><ul><li><code class="language-plaintext highlighter-rouge">if=/dev/sdb</code>: This is our input (source) file (<code class="language-plaintext highlighter-rouge">if</code>), which in this case is the block device associated with the USB device.<li><code class="language-plaintext highlighter-rouge">of=USB_image.dd</code>: The output (destination) file (<code class="language-plaintext highlighter-rouge">of</code>), which will be a raw image file consisting of all the accessible data on the USB device acquired by DD.<li><code class="language-plaintext highlighter-rouge">bs=4k</code>: This specifies the size of the data blocks to be copied from the input file in bytes. If this option is not specified, it will default to a block size of 512, analogous to the traditional sector size on a hard drive. In this case, I used a block size of 4k (4096), which was optimal for my setup<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>. Larger block sizes are used for efficiency purposes but I would recommend using smaller block sizes where possible, because if you encounter read errors, you risk zero-filling readable data on a larger block size.<li><code class="language-plaintext highlighter-rouge">conv=noerror,sync</code>: This option is vital if you run the <code class="language-plaintext highlighter-rouge">dd</code> command against a disk you suspect of having ‘bad’ or ‘defective’ blocks/sectors. Normally, the <code class="language-plaintext highlighter-rouge">dd</code> tool will abruptly terminate the command if a read error is encountered from the source drive, which the <code class="language-plaintext highlighter-rouge">noerror</code> parameter prevents. However, you will also need to use the <code class="language-plaintext highlighter-rouge">sync</code> option in conjunction with <code class="language-plaintext highlighter-rouge">noerror</code>, which will pad any unreadable ‘bad’ blocks with zeros in the output file. Bear in mind that should this occur, the resulting image will not match the original drive when hashes are calculated for each. To counter this, you can calculate hashes in specified intervals using the <code class="language-plaintext highlighter-rouge">dcfldd</code> tool (see <strong>DCFLDD</strong> tool section below).</ul><h3 id="reading-the-mbr">Reading the MBR</h3><p>I personally do not use traditional <code class="language-plaintext highlighter-rouge">dd</code> for forensic imaging, however, it is very useful when extracting key excerpts of data from a drive. For example, the following <code class="language-plaintext highlighter-rouge">dd</code> command will extract the first 512 bytes of the accessible data, known as the Master Boot Record (MBR):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>dd if=/dev/sdb of=USB_mbr.dd bs=512 count=1
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">count=1</code>: This specifies how many blocks, whose size we define with <code class="language-plaintext highlighter-rouge">bs</code>, are to be extracted. In the above command; I only required a single block, starting at the beginning of the accessible data. This particular block of data is also referred to as the MBR ‘boot sector’ (<code class="language-plaintext highlighter-rouge">0x55AA</code> signature), which contains partition and Operating System information, as well as boot code used by the BIOS.</ul><h3 id="additional-parameters">Additional Parameters</h3><p>A few other less common parameters used with <code class="language-plaintext highlighter-rouge">dd</code>, along with their function, are described as follows:</p><ul><li><code class="language-plaintext highlighter-rouge">skip=X</code>: Where ‘<em>X</em>’ is an integer. This option will exclude X amount of blocks, of block size <code class="language-plaintext highlighter-rouge">bs=X</code> at the start of the input file. For example, if an input file of 100 blocks is imaged with <code class="language-plaintext highlighter-rouge">skip=1</code>, the resulting output file will be 99 blocks in size, having excluded the first block.<li><code class="language-plaintext highlighter-rouge">conv=sparse</code>: This option should generally be used to save space on the file system, as any zeroed blocks in the output file wont be written to disk. For further reading into sparse files, I recommend this <a href="https://wiki.archlinux.org/index.php/Sparse_file">resource</a>.<li><code class="language-plaintext highlighter-rouge">status=progress</code>: This option will cause DD to show periodic transfer statistics such as; the amount of bytes copied, the elapsed time and the data transfer rate. Typically used for convenience purposes but can help determine optimal block sizes.</ul><h2 id="tool-2-dcfldd">Tool #2: DCFLDD</h2><p>The first tool I will cover that has been forked from the DD project is called <code class="language-plaintext highlighter-rouge">dcfldd</code>, which was developed by the Department of Defense Computer Forensic Lab and is considered to be an enhanced version of the traditional <code class="language-plaintext highlighter-rouge">dd</code>. It boasts notable improvements over the original such as:</p><ul><li>Multiple output file support<li>Hash verification<li>Hashing during data transfer<li>Split output file support<li>Log file support<li>In-built status progress</ul><p>Bear in mind that <code class="language-plaintext highlighter-rouge">dcfldd</code> does not support any output format other than ‘RAW’, meaning this tool cannot be used to output to forensic formats such as AFF, EWF, E01, etc. In addition, this tool should not be used when dealing with disks you suspect of containing defective sectors, due to a known issue in the tool itself<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup>.</p><p>Most of the common Linux distributions contain <code class="language-plaintext highlighter-rouge">dcfldd</code> in their core repositories and can be very easily installed from the command line. For a list of commands to help install <code class="language-plaintext highlighter-rouge">dcfldd</code>, please check for the appropriate distribution <a href="https://pkgs.org/download/dcfldd">here</a>. Note that Arch Linux and CentOS distributions will require additional repositories to be setup before <code class="language-plaintext highlighter-rouge">dcfldd</code> can be installed.</p><p>When using <code class="language-plaintext highlighter-rouge">dcfldd</code> on the Linux command-line; given the block device we want to image is <code class="language-plaintext highlighter-rouge">/dev/sdb</code>, a typical command would look like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>dcfldd if=/dev/sdb of=USB_Image.dd of=USB_Image2.dd bs=4k conv=noerror,sync hash=sha256 hashwindow=100MB sha256log=USB_Image.hash
</pre></table></code></div></div><h3 id="dcfldd-parameters">DCFLDD Parameters</h3><p>The <code class="language-plaintext highlighter-rouge">bs</code> and <code class="language-plaintext highlighter-rouge">conv</code> parameters have not changed from their usage in the DD tool, please refer to the previous demonstration of <code class="language-plaintext highlighter-rouge">dd</code> for more details on these options.</p><ul><li><code class="language-plaintext highlighter-rouge">of=USB_Image2.dd</code>: In the command above, I have specified a second output file option, with a different file name, meaning I end up with two identical images of the source file (<code class="language-plaintext highlighter-rouge">/dev/sdb</code>). This may not be useful when dealing with very large datasets, however it does allow an examiner to save an image to different locations if necessary.<li><code class="language-plaintext highlighter-rouge">hash=sha256</code>: This option selects the hashing algorithm SHA-256 to be used when calculating a cryptographic hash of the input and output files. The hashing algorithms MD5, SHA-1, SHA-256, SHA-384 and SHA-512 are currently supported within <code class="language-plaintext highlighter-rouge">dcfldd</code>. I would not recommend using MD5 or SHA-1 as they have been cryptographically broken<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup>.<li><code class="language-plaintext highlighter-rouge">hashwindow=100MB</code>: As mentioned previously, this option will calculate a hash of the data in specified intervals, in this case, every 100MB of data. This can be seen in the output log file specified with the next option.<li><code class="language-plaintext highlighter-rouge">sha256log=USB_Image.hash</code>: A good example of the logging functionality of <code class="language-plaintext highlighter-rouge">dcfldd</code>, this option designates a separate file which will store the calculated hashes we specified previously. As shown in command above, this file contains a hash value for each 100MB of data, including the value for the whole data at the end. To check that this last hash value matched the source device, I ran <code class="language-plaintext highlighter-rouge">sha256sum</code> against the block device.</ul><p>The <code class="language-plaintext highlighter-rouge">dcfldd</code> tool contains many other options and I would recommend reading through the man page if you want to take full advantage of its functionality. Like traditional <code class="language-plaintext highlighter-rouge">dd</code>; <code class="language-plaintext highlighter-rouge">dcfldd</code> also contains the options <code class="language-plaintext highlighter-rouge">count</code>, <code class="language-plaintext highlighter-rouge">skip</code> and <code class="language-plaintext highlighter-rouge">status</code>, except the status command operates with a simple on/off parameter instead (e.g. <code class="language-plaintext highlighter-rouge">status=on</code>).</p><p>Like <code class="language-plaintext highlighter-rouge">dd</code>, I do not personally use <code class="language-plaintext highlighter-rouge">dcfldd</code> for forensic acquisition, primarily due to the reported issues it has with defective sectors. However, the ability to calculate a hash value at specified intervals can prove very useful in some circumstances.</p><h2 id="tool-3-dc3dd">Tool #3: DC3DD</h2><p>The second derivative of dd that I am covering is <code class="language-plaintext highlighter-rouge">dc3dd</code>, which was developed by the Department of Defense Cyber Crime Center. DC3DD is very syntactically and functionally similar to the previous tool <code class="language-plaintext highlighter-rouge">dcfldd</code>. However, there are some slight differences between the two, the most notable being that the <code class="language-plaintext highlighter-rouge">conv=noerror,sync</code> option and the progress bar are built into <code class="language-plaintext highlighter-rouge">dc3dd</code> by default. Additionally, <code class="language-plaintext highlighter-rouge">dc3dd</code> allows for automatic hash verification, which is a very useful feature not found in the other DD tools.</p><p>Again, most of the common Linux distributions contain <code class="language-plaintext highlighter-rouge">dc3dd</code> in their core repositories and can be very easily installed from the command line. For a list of commands to help install <code class="language-plaintext highlighter-rouge">dc3dd</code>, please check the appropriate distribution <a href="https://pkgs.org/download/dc3dd">here</a>. Note that CentOS will require either the EPEL, Repoforge or CERT Forensic repositories to be setup beforehand.</p><p>Using <code class="language-plaintext highlighter-rouge">dc3dd</code> on the Linux command-line has plenty of options for forensic examiners. Given the block device we want to image is <code class="language-plaintext highlighter-rouge">/dev/sdb</code>, a typical <code class="language-plaintext highlighter-rouge">dc3dd</code> command would look like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>dc3dd if=/dev/sdb hof=USB_Image.dd log=USB_Image.log hash=sha256 hash=sha512 hlog=USB_Image.hash
</pre></table></code></div></div><h3 id="dc3dd-parameters">DC3DD Parameters</h3><ul><li><code class="language-plaintext highlighter-rouge">hof=USB_Image.dd</code>: This option will calculate a hash of the specified output file, as well as compare this value to the one calculated for the input file. Should the hashes match, the command will output ‘[ok]’ next to the hash values in <code class="language-plaintext highlighter-rouge">STDOUT</code>.<li><code class="language-plaintext highlighter-rouge">log=USB_Image.log</code>: This option will write the contents of <code class="language-plaintext highlighter-rouge">STDOUT</code> to a specified file. This is useful because if you plan on using <code class="language-plaintext highlighter-rouge">dc3dd</code> multiple times, you can write to the same log file each time, as it will not be overwritten.<li><code class="language-plaintext highlighter-rouge">hlog=USB_Image.hash</code>: Specifies a file where the hash value comparison is written to. If the hash verification is written to <code class="language-plaintext highlighter-rouge">STDOUT</code>, it will appear here and in the file specified by <code class="language-plaintext highlighter-rouge">log=</code>.</ul><h3 id="additional-parameters-1">Additional Parameters</h3><p>As seen before in <code class="language-plaintext highlighter-rouge">dcfldd</code>, I manually specified which hash algorithms I wanted the tool to use with the <code class="language-plaintext highlighter-rouge">hash=</code> option. I used two (SHA-256 and SHA-512), with the same rational that MD5 and SHA-1 are broken. It is worth noting that <code class="language-plaintext highlighter-rouge">dc3dd</code> has different names for the options seen in the previous tools, which I have listed as follows:</p><ul><li><code class="language-plaintext highlighter-rouge">count = cnt</code>: Will read a specified amount of blocks from the input file. The size of these blocks can be altered with the <code class="language-plaintext highlighter-rouge">ssz</code> option below.<li><code class="language-plaintext highlighter-rouge">skip = iskip/oskip</code>: Here <code class="language-plaintext highlighter-rouge">skip</code> is split into two options for input and output. <code class="language-plaintext highlighter-rouge">iskip</code> will specify the amount of blocks to skip at the start of the input file and <code class="language-plaintext highlighter-rouge">oskip</code> will specify the same but for the output file.<li><code class="language-plaintext highlighter-rouge">bs = ssz</code>: The default block size in <code class="language-plaintext highlighter-rouge">dc3dd</code> is 512, but this can be manually overwritten using <code class="language-plaintext highlighter-rouge">ssz</code>. Bear in mind that this will still accept non-absolute values like ‘4k’ (4096).</ul><p>The <code class="language-plaintext highlighter-rouge">dc3dd</code> derivative tool is an excellent choice for forensic examiners due its hash verification and advanced logging features. In the forensic imaging process, I personally use a combination of this tool and the next one; <code class="language-plaintext highlighter-rouge">ddrescue</code>. As a side note; <code class="language-plaintext highlighter-rouge">dc3dd</code> is the imaging tool utilised in Bruce Nikkel’s <code class="language-plaintext highlighter-rouge">sfsimage</code> program, which I highly recommend checking out <a href="https://digitalforensics.ch/sfsimage/">here</a>.</p><h2 id="tool-4-ddrescue">Tool #4: DDRESCUE</h2><p>The final tool I will be covering is technically not a derivative of <code class="language-plaintext highlighter-rouge">dd</code>, but functions in a very similar way and is very useful for forensic imaging, despite being considered a ‘data recovery’ tool. The tool <code class="language-plaintext highlighter-rouge">ddrescue</code> was developed as part of the GNU project and is not to be mistaken with <code class="language-plaintext highlighter-rouge">dd_rescue</code>, which <code class="language-plaintext highlighter-rouge">ddrescue</code> is considered to be an improvement upon<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup>. Because <code class="language-plaintext highlighter-rouge">ddrescue</code> is primarily focused on data recovery, it is the ideal tool to utilise on devices that are suspected to contain ‘bad’ blocks.</p><p>Like the previous two tools, <code class="language-plaintext highlighter-rouge">ddrescue</code> is fairly easy to install on most Linux distributions due to its inclusion in their core repositories. For a list of distributions with appropriate commands and instructions needed to install <code class="language-plaintext highlighter-rouge">ddrescue</code>, please refer to this <a href="https://pkgs.org/download/ddrescue">resource</a>.</p><p>Despite being more oriented towards data recovery, <code class="language-plaintext highlighter-rouge">ddrescue</code> still provides options which will prove useful for forensic practitioners. As before, assuming the device we want to image is <code class="language-plaintext highlighter-rouge">/dev/sdb</code>, a typical <code class="language-plaintext highlighter-rouge">ddrescue</code> command would look like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ddrescue -d /dev/sdb USB_Image.dd USB_Image.map
</pre></table></code></div></div><h3 id="ddrescue-parameters">DDRESCUE Parameters</h3><p>Note how we do not need to specify the <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">of</code> options for the input and output files respectively as seen in the other tools.</p><ul><li><code class="language-plaintext highlighter-rouge">-d / --idirect</code>: This option specifies direct disc access for the input file and will bypass the kernel cache. Note that not all systems support direct disc access and <code class="language-plaintext highlighter-rouge">ddrescue</code> will warn you if your system does not.<li><code class="language-plaintext highlighter-rouge">USB_Image.map</code>: This is the third parameter of <code class="language-plaintext highlighter-rouge">ddrescue</code> and despite being optional, it is highly recommended you use a map file. Note that the map file does not need to obey any naming convention like <code class="language-plaintext highlighter-rouge">*.map</code> and can be named however you wish. The map file will contain important information about the imaging process, specifically whether there were any read errors during the acquisition. Additionally, should the imaging process be interrupted for any reason, the map file will keep track of the recovered data and as long as the same map file is specified, the imaging can resume where it left off.</ul><p>The <a href="https://www.gnu.org/software/ddrescue/manual/ddrescue_manual.html">documentation</a> for <code class="language-plaintext highlighter-rouge">ddrescue</code> is very robust and well worth reading through if you have time. From the manual I have picked out some features that I found particularly interesting:</p><ul><li>Specifying the option <code class="language-plaintext highlighter-rouge">-R</code> will read the input file in reverse passes. Like many of the options, this is used mainly to maximise recovered data on bad disks.<li>Should <code class="language-plaintext highlighter-rouge">ddrescue</code> encounter bad sectors on the input file you are imaging, it will not write zeros to the output file in their place like the other <code class="language-plaintext highlighter-rouge">dd</code> tools will do.<li>The physical block size will be dynamically decreased to maximise recovered data should <code class="language-plaintext highlighter-rouge">ddrescue</code> encounter bad sectors on the input file.<li>Any interface (ATA, SATA, SCSI, etc.) supported by your kernel can be used with <code class="language-plaintext highlighter-rouge">ddrescue</code>.<li>The <code class="language-plaintext highlighter-rouge">-i</code> option can be used to specify a starting position on the input file. The option defaults to offset <code class="language-plaintext highlighter-rouge">0</code> if not specified.</ul><h2 id="concluding-statements">Concluding Statements</h2><p>I decided to discuss data completeness at the beginning of this article because I believe it is very important for forensic practitioners to understand exactly what data they are acquiring from a device, and consider that it may not always be ‘forensically complete’.</p><p>All the tools covered in this article have their own strengths and weaknesses so your individual circumstances will be the biggest factor in deciding which you want to use. However, in my opinion, I would always utilise <code class="language-plaintext highlighter-rouge">ddrescue</code> for imaging drives whenever possible due to its focus on recovering ‘good’ data. Of course, you may not necessarily be in a position to choose one over the other, which is why I emphasise learning how each of them work.</p><p>I am aware that there are many other uses/options for the tools covered in this article, but I wanted to show that fundamentally, the forensic imaging process can be completed with command-line tools on Linux. Finally, this is by no means an exhaustive list of imaging tools fit for every possible scenario you may come across.</p><p>If you have any recommendations or questions about the topics mentioned in this article, you can contact me on <a href="https://twitter.com/AstrumMairi">Twitter</a>.</p><p>– Mairi</p><h2 id="references">References</h2><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p>Burles, N. (2013). <a href="https://www.nburles.co.uk/android/recovering-data-from-an-android-device-using-dd">Recovering data from an Android device using dd</a> [Accessed 2018-01-28] <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:2" role="doc-endnote"><p>Shema, M., Davis, C. and Cowen, D. (2004). <em>Anti-Hacker Tool Kit</em>, 3rd Ed. California: McGraw-Hill <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:3" role="doc-endnote"><p>Nikkel, B. (2016). <em>Practical Forensic Imaging</em>. San Francisco: No Starch Press, Inc. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:4" role="doc-endnote"><p>Shipley, T. and Door, B. (2016) <a href="https://www.forensicfocus.com/articles/hiding-data-from-forensic-imagers-using-the-service-area-of-a-hard-disk-drive/">Hiding Data from Forensic Imagers – Using the Service Area of a Hard Disk Drive</a> [Accessed 2018-01-28] <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:5" role="doc-endnote"><p>Shipley, T. and Door, B. (2012). <a href="https://www.forensicfocus.com/articles/forensic-imaging-of-hard-disk-drives-what-we-thought-we-knew-2/">Forensic Imaging of Hard Disk Drives- What we thought we knew</a> [Accessed 2018-01-28] <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:6" role="doc-endnote"><p>Peacock, C. (2018). <a href="https://www.beyondlogic.org/usbnutshell/usb5.shtml#DeviceDescriptors">USB Descriptors</a> [Accessed 2018-01-28] <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:7" role="doc-endnote"><p>Larabel, M. (2014). <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=MTcyMTk">USB Attached SCSI (UAS) Is Now Working Under Linux</a> [Accessed 2018-01-28] <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:8" role="doc-endnote"><p>ForensicsWiki. (2013). <a href="https://forensicswiki.xyz/wiki/index.php?title=Dd">Dd</a> [Accessed 2018-01-28] <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:9" role="doc-endnote"><p>Gunther, D. (2015). <a href="http://blog.tdg5.com/tuning-dd-block-size/">Tuning dd block size</a> [Accessed 2018-01-28] <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:10" role="doc-endnote"><p>Lyle, J. R. and Wozar, M. R. (2007). <em>Issues with Imaging Drives Containing Faulty Sectors</em>. Digital Investigation: Volume 4 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:11" role="doc-endnote"><p>Umbelino, P. (2017). <a href="https://hackaday.com/2017/02/23/shattered-sha-1-is-broken/">SHAttered — SHA-1 Is Broken In</a> [Accessed 2018-01-28] <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:12" role="doc-endnote"><p>jabby. (2011). <a href="https://lwn.net/Articles/430000/">ddrescue vs. dd_rescue</a> [Accessed 2018-01-28] <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dfir/'>DFIR</a>, <a href='/categories/linux/'>Linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/dfir/" class="post-tag no-text-decoration" >dfir</a> <a href="/tags/linux/" class="post-tag no-text-decoration" >linux</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Forensic Acquisition with DD Tools - Mairi's Blog&url=https://tmairi.github.io/posts/forensic-aquisition-with-dd-tools/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Forensic Acquisition with DD Tools - Mairi's Blog&u=https://tmairi.github.io/posts/forensic-aquisition-with-dd-tools/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Forensic Acquisition with DD Tools - Mairi's Blog&url=https://tmairi.github.io/posts/forensic-aquisition-with-dd-tools/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/dissecting-the-ad1-file-format/">Dissecting the AD1 File Format</a><li><a href="/posts/exploring-ieee-754-arithmetic/">Exploring IEEE 754 Arithmetic</a><li><a href="/posts/LNKPARSER/">Forensic BASH Scripting: LNK Parsing</a><li><a href="/posts/forensic-aquisition-with-dd-tools/">Forensic Acquisition with DD Tools</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/dfir/">dfir</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/scripting/">scripting</a> <a class="post-tag" href="/tags/mathematics/">mathematics</a> <a class="post-tag" href="/tags/windows/">windows</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/extracting-alternate-data-streams-with-linux/"><div class="card-body"> <span class="timeago small" > Jun 22 <i class="unloaded">2018-06-22T01:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Extracting Alternate Data Streams with Linux</h3><div class="text-muted small"><p> Foreword This article will be covering a feature of the NTFS file system known as the Alternate Data Stream (ADS), focusing on how to properly identify and extract these data streams from an NTFS ...</p></div></div></a></div><div class="card"> <a href="/posts/LNKPARSER/"><div class="card-body"> <span class="timeago small" > Apr 8 <i class="unloaded">2021-04-08T20:56:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Forensic BASH Scripting: LNK Parsing</h3><div class="text-muted small"><p> Forensic BASH script: lnkparser Observation Recently, while probing a Windows image file in my spare time, I came across a plethora of user-generated Windows shortcut files, also known as LNK fil...</p></div></div></a></div><div class="card"> <a href="/posts/dissecting-the-ad1-file-format/"><div class="card-body"> <span class="timeago small" > Jun 19 <i class="unloaded">2021-06-19T23:48:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Dissecting the AD1 File Format</h3><div class="text-muted small"><p> Foreword This article will be covering my personal exploration and dissection of the proprietary AccessData image format known as the AccessData Logial Image. This format is also referred to as AD...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <a href="/posts/extracting-alternate-data-streams-with-linux/" class="btn btn-outline-primary" prompt="Newer"><p>Extracting Alternate Data Streams with Linux</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/AstrumMairi">Mairi</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/dfir/">dfir</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/scripting/">scripting</a> <a class="post-tag" href="/tags/mathematics/">mathematics</a> <a class="post-tag" href="/tags/windows/">windows</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://tmairi.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
